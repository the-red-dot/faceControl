<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Facial Expression Control System</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #1a1a1a; color: #e5e5e5; overflow: hidden; /* Prevent body scroll */ }
        /* Custom Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
            transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #4b5563;
            border-radius: 2px;
        }
        input[type=range]:focus {
            outline: none;
        }
        
        /* Video Container Handling */
        .video-wrapper {
            position: relative;
            background: #000;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
            margin: 0 auto;
        }

        /* Aspect Ratio Classes */
        .ratio-wide { aspect-ratio: 16 / 9; width: 100%; }
        .ratio-square { aspect-ratio: 1 / 1; width: 100%; }
        .ratio-vertical { aspect-ratio: 9 / 16; width: 100%; }

        /* Full Screen Override */
        .fs-mode .video-wrapper {
            width: 100% !important;
            height: 100% !important;
            aspect-ratio: auto !important;
            border-radius: 0;
        }

        /* Responsive Constraints for Mobile Vertical */
        @media (max-height: 800px) {
            .ratio-vertical {
                max-height: 50vh; /* Don't let vertical video take up too much height on small phones */
                width: auto;      /* Let width adjust to maintain ratio */
                margin: 0 auto;
            }
        }

        .layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* ESSENTIAL: Ensures no black spots */
            object-position: top center; /* Focus on face usually at top/center */
            opacity: 0;
            transition: opacity 0.2s ease-out;
            pointer-events: none;
        }
        .layer.active {
            opacity: 1;
        }

        /* Spinner */
        .spinner {
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top: 3px solid #3b82f6;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        const VIDEO_SLOTS = [
            { id: 'idle', label: 'Idle / Default', filename: 'Idle_Video.mp4', type: 'idle' },
            { id: 'head_left_right', label: 'Head Rotate (Left/Right)', filename: 'head_left_right.mp4', type: 'action' },
            { id: 'head_up_down', label: 'Head Tilt (Up/Down)', filename: 'head_up_down.mp4', type: 'action' },
            { id: 'mouth_wide', label: 'Mouth Open', filename: 'mouth_wide.mp4', type: 'action' },
            { id: 'zoom_in_out', label: 'Zoom In/Out', filename: 'zoom_in_out.mp4', type: 'action' }
        ];

        const FPS_SAMPLE_RATE = 30; 

        // --- IndexedDB Helpers ---
        const DB_NAME = 'FaceControlDB';
        const VIDEO_STORE = 'videos';
        const FRAME_STORE = 'frames';
        const DB_VERSION = 2;

        const initDB = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(VIDEO_STORE)) db.createObjectStore(VIDEO_STORE);
                    if (!db.objectStoreNames.contains(FRAME_STORE)) db.createObjectStore(FRAME_STORE);
                };
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });
        };

        const saveBlobToDB = async (storeName, id, data) => {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                store.put(data, id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        };

        const getFromDB = async (storeName, id) => {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, 'readonly');
                const store = tx.objectStore(storeName);
                const request = store.get(id);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        };

        const clearDB = async () => {
             const db = await initDB();
             return new Promise((resolve, reject) => {
                 const tx = db.transaction([VIDEO_STORE, FRAME_STORE], 'readwrite');
                 tx.objectStore(VIDEO_STORE).clear();
                 tx.objectStore(FRAME_STORE).clear();
                 tx.oncomplete = () => resolve();
             });
        }


        function App() {
            // --- State ---
            const [videoSources, setVideoSources] = useState({});
            const [frameData, setFrameData] = useState({});
            const [loadingState, setLoadingState] = useState({});
            const [cacheStatus, setCacheStatus] = useState({}); 
            const [aspectRatio, setAspectRatio] = useState('wide'); // 'wide', 'square', 'vertical'
            
            const [configs, setConfigs] = useState(() => {
                const saved = localStorage.getItem('face_control_configs');
                if (saved) return JSON.parse(saved);
                const defaults = {};
                VIDEO_SLOTS.forEach(slot => {
                    if (slot.type === 'action') defaults[slot.id] = { start: 0, neutral: 15, end: 30 }; 
                });
                return defaults;
            });

            const [globalReturnSpeed, setGlobalReturnSpeed] = useState(() => {
                const saved = localStorage.getItem('face_control_global_speed');
                return saved ? parseFloat(saved) : 5;
            });

            const [activeActionId, setActiveActionId] = useState(null);
            const [uiSliderValues, setUiSliderValues] = useState({}); 
            const [isFullScreen, setIsFullScreen] = useState(false);

            // --- Refs ---
            const idleVideoRef = useRef(null);
            const actionCanvasRef = useRef(null);
            const sliderValuesRef = useRef({}); 
            const isDraggingRef = useRef({});
            const isReturningRef = useRef({});
            const loopRef = useRef(null);
            const lastTimeRef = useRef(Date.now());

            useEffect(() => {
                VIDEO_SLOTS.forEach(slot => {
                    if (slot.type === 'action') {
                        sliderValuesRef.current[slot.id] = 50; 
                        isDraggingRef.current[slot.id] = false;
                        isReturningRef.current[slot.id] = false;
                    }
                });
                setUiSliderValues({...sliderValuesRef.current});
                loadProject();

                const handleFsChange = () => setIsFullScreen(!!document.fullscreenElement);
                document.addEventListener('fullscreenchange', handleFsChange);
                return () => document.removeEventListener('fullscreenchange', handleFsChange);
            }, []);

            useEffect(() => { localStorage.setItem('face_control_configs', JSON.stringify(configs)); }, [configs]);
            useEffect(() => { localStorage.setItem('face_control_global_speed', globalReturnSpeed.toString()); }, [globalReturnSpeed]);

            const loadProject = async () => {
                for (const slot of VIDEO_SLOTS) {
                    try {
                        if (slot.type === 'idle') {
                            const blob = await getFromDB(VIDEO_STORE, slot.id);
                            if (blob) setVideoSources(prev => ({ ...prev, [slot.id]: URL.createObjectURL(blob) }));
                        } else {
                            const cachedFrames = await getFromDB(FRAME_STORE, slot.id);
                            if (cachedFrames) {
                                const bitmaps = await Promise.all(cachedFrames.map(blob => createImageBitmap(blob)));
                                setFrameData(prev => ({ ...prev, [slot.id]: bitmaps }));
                                setCacheStatus(prev => ({...prev, [slot.id]: 'cached'}));
                            }
                        }
                    } catch (e) { console.error(`Error loading ${slot.id}`, e); }
                }
            };

            const resetProject = async () => {
                if(confirm("Are you sure you want to delete all saved videos and settings?")) {
                    await clearDB();
                    localStorage.removeItem('face_control_configs');
                    localStorage.removeItem('face_control_global_speed');
                    window.location.reload();
                }
            }

            const toggleFullScreen = () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(e => console.error(e));
                } else {
                    if (document.exitFullscreen) document.exitFullscreen();
                }
            };

            const extractAndCacheFrames = async (blob, slotId) => {
                return new Promise((resolve) => {
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(blob);
                    video.muted = true;
                    video.playsInline = true;
                    video.preload = 'auto';
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    const frames = [];
                    const frameBlobs = []; 

                    video.onloadedmetadata = async () => {
                        canvas.width = video.videoWidth; 
                        canvas.height = video.videoHeight;
                        const duration = video.duration;
                        let currentTime = 0;
                        const step = 1 / FPS_SAMPLE_RATE;

                        const seekResolve = () => new Promise(r => {
                            const onSeek = () => { video.removeEventListener('seeked', onSeek); r(); };
                            video.addEventListener('seeked', onSeek);
                            video.currentTime = currentTime;
                        });

                        while (currentTime < duration) {
                            await seekResolve();
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                            const bitmap = await createImageBitmap(canvas);
                            frames.push(bitmap);
                            const blobPromise = new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.9));
                            const blobData = await blobPromise;
                            frameBlobs.push(blobData);
                            currentTime += step;
                        }
                        
                        saveBlobToDB(FRAME_STORE, slotId, frameBlobs).then(() => {
                            setCacheStatus(prev => ({...prev, [slotId]: 'cached'}));
                        });
                        resolve(frames);
                    };
                });
            };

            const handleFileProcess = async (slotId, file) => {
                if (!file) return;
                const slot = VIDEO_SLOTS.find(s => s.id === slotId);
                
                if (slot.type === 'idle') {
                    setVideoSources(prev => ({ ...prev, [slotId]: URL.createObjectURL(file) }));
                    saveBlobToDB(VIDEO_STORE, slotId, file);
                } else {
                    setLoadingState(prev => ({ ...prev, [slotId]: true }));
                    try {
                        const frames = await extractAndCacheFrames(file, slotId);
                        setFrameData(prev => ({ ...prev, [slotId]: frames }));
                        
                        setConfigs(prev => {
                           const current = prev[slotId];
                           const maxFrame = frames.length - 1;
                           if (current.neutral > maxFrame || current.end > maxFrame) {
                               return { ...prev, [slotId]: { start: 0, neutral: Math.floor(maxFrame / 2), end: maxFrame } };
                           }
                           return prev;
                        });
                    } catch (e) { console.error(e); }
                    setLoadingState(prev => ({ ...prev, [slotId]: false }));
                }
            };

            const getFrameIndex = (slotId, sliderVal) => {
                const frames = frameData[slotId];
                const config = configs[slotId];
                if (!frames || frames.length === 0 || !config) return 0;
                let targetFrame = 0;
                if (sliderVal <= 50) {
                    const ratio = sliderVal / 50;
                    targetFrame = config.start + (config.neutral - config.start) * ratio;
                } else {
                    const ratio = (sliderVal - 50) / 50;
                    targetFrame = config.neutral + (config.end - config.neutral) * ratio;
                }
                return Math.max(0, Math.min(frames.length - 1, Math.round(targetFrame)));
            };

            const renderLoop = useCallback(() => {
                const now = Date.now();
                const dt = Math.min((now - lastTimeRef.current) / 1000, 0.1);
                lastTimeRef.current = now;
                let needsUiUpdate = false;
                const newUiValues = {};

                VIDEO_SLOTS.forEach(slot => {
                    if (slot.type !== 'action') return;
                    const id = slot.id;
                    if (isReturningRef.current[id]) {
                        const current = sliderValuesRef.current[id];
                        const target = 50;
                        const diff = target - current;
                        const speed = globalReturnSpeed;
                        if (Math.abs(diff) < 0.2) {
                            sliderValuesRef.current[id] = target;
                            isReturningRef.current[id] = false;
                        } else {
                            sliderValuesRef.current[id] += diff * speed * dt;
                        }
                        needsUiUpdate = true;
                        newUiValues[id] = sliderValuesRef.current[id];
                    }
                });

                const canvas = actionCanvasRef.current;
                const ctx = canvas ? canvas.getContext('2d') : null;

                if (activeActionId && frameData[activeActionId] && ctx) {
                    const frames = frameData[activeActionId];
                    const val = sliderValuesRef.current[activeActionId];
                    const frameIdx = getFrameIndex(activeActionId, val);
                    const image = frames[frameIdx];
                    if (image) {
                        if (canvas.width !== image.width) canvas.width = image.width;
                        if (canvas.height !== image.height) canvas.height = image.height;
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(image, 0, 0);
                    }
                } 
                
                if (activeActionId && !isDraggingRef.current[activeActionId] && !isReturningRef.current[activeActionId] && Math.abs(sliderValuesRef.current[activeActionId] - 50) < 0.2) {
                    setActiveActionId(null);
                }

                if (needsUiUpdate) setUiSliderValues(prev => ({ ...prev, ...newUiValues }));
                loopRef.current = requestAnimationFrame(renderLoop);
            }, [activeActionId, configs, frameData, globalReturnSpeed]);

            useEffect(() => {
                loopRef.current = requestAnimationFrame(renderLoop);
                return () => cancelAnimationFrame(loopRef.current);
            }, [renderLoop]);

            const handleSliderStart = (id) => {
                if (loadingState[id]) return; 
                isDraggingRef.current[id] = true;
                isReturningRef.current[id] = false;
                setActiveActionId(id);
                if (idleVideoRef.current) idleVideoRef.current.pause();
            };

            const handleSliderMove = (id, val) => {
                if (loadingState[id]) return;
                const numVal = parseFloat(val);
                sliderValuesRef.current[id] = numVal;
                setUiSliderValues(prev => ({ ...prev, [id]: numVal }));
            };

            const handleSliderEnd = (id) => {
                if (loadingState[id]) return;
                isDraggingRef.current[id] = false;
                isReturningRef.current[id] = true;
            };

            const handleConfigChange = (id, field, val) => {
                const numVal = parseFloat(val);
                setConfigs(prev => ({ ...prev, [id]: { ...prev[id], [field]: numVal } }));
            };

            useEffect(() => {
                const idleVideo = idleVideoRef.current;
                if (idleVideo) {
                    if (!activeActionId) idleVideo.play().catch(() => {});
                    else idleVideo.pause();
                }
            }, [activeActionId]);

            const allFilesLoaded = VIDEO_SLOTS.every(slot => {
                if (slot.type === 'idle') return !!videoSources[slot.id];
                return !!frameData[slot.id];
            });

            // Layout helpers
            const getRatioClass = () => {
                if (isFullScreen) return 'fs-mode';
                if (aspectRatio === 'wide') return 'ratio-wide';
                if (aspectRatio === 'square') return 'ratio-square';
                if (aspectRatio === 'vertical') return 'ratio-vertical';
                return 'ratio-wide';
            };

            return (
                // Use h-dvh (Dynamic Viewport Height) for perfect mobile fit
                <div className={isFullScreen 
                    ? "fixed inset-0 z-50 bg-black flex flex-col font-sans overflow-hidden" 
                    : "h-dvh flex flex-col bg-[#1a1a1a] font-sans overflow-hidden"}>
                    
                    {/* Top Bar / Header */}
                    <div className="flex-none p-4 flex justify-between items-center bg-gray-900 border-b border-gray-800 z-50 shadow-md">
                        <div className="flex items-center gap-4">
                            {!isFullScreen && (
                                <h1 className="text-xl md:text-2xl font-bold text-white hidden md:block">Facial Control</h1>
                            )}
                            
                            {/* Aspect Ratio Toggles */}
                            <div className="flex bg-gray-800 rounded p-1 border border-gray-700">
                                <button onClick={() => setAspectRatio('wide')} className={`px-3 py-1 text-xs rounded transition-colors ${aspectRatio==='wide' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-gray-200'}`}>16:9</button>
                                <button onClick={() => setAspectRatio('square')} className={`px-3 py-1 text-xs rounded transition-colors ${aspectRatio==='square' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-gray-200'}`}>1:1</button>
                                <button onClick={() => setAspectRatio('vertical')} className={`px-3 py-1 text-xs rounded transition-colors ${aspectRatio==='vertical' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-gray-200'}`}>9:16</button>
                            </div>
                        </div>

                        <div className="flex gap-2">
                            <button onClick={toggleFullScreen} className="bg-blue-900/50 hover:bg-blue-700 text-blue-200 px-3 py-1 rounded text-xs border border-blue-700 transition-colors flex items-center gap-1 whitespace-nowrap">
                                {isFullScreen ? '‚Üô Exit' : '‚õ∂ Full'}
                            </button>
                            {!isFullScreen && (
                                <button onClick={resetProject} className="bg-red-900/50 hover:bg-red-700 text-red-200 px-3 py-1 rounded text-xs border border-red-700 transition-colors whitespace-nowrap">
                                    üóëÔ∏è Reset
                                </button>
                            )}
                        </div>
                    </div>

                    {!allFilesLoaded && !isFullScreen && (
                        <div className="absolute inset-0 z-40 bg-black/80 flex items-center justify-center p-4">
                            <div className="bg-gray-800 border border-gray-700 rounded-lg p-6 max-w-2xl w-full shadow-2xl">
                                <h2 className="text-xl font-semibold text-blue-400 mb-4 flex items-center"><span className="mr-2">üìÇ</span> Setup: Load Assets</h2>
                                <p className="text-gray-300 mb-6 text-sm">Select files. Frames are auto-saved to DB.</p>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 max-h-[60vh] overflow-y-auto">
                                    {VIDEO_SLOTS.map(slot => {
                                        const isLoaded = slot.type === 'idle' ? !!videoSources[slot.id] : !!frameData[slot.id];
                                        const isLoading = loadingState[slot.id];
                                        const isCached = cacheStatus[slot.id] === 'cached';
                                        return (
                                            <div key={slot.id} className={`p-4 rounded border ${isLoaded ? 'border-green-500 bg-green-900/20' : 'border-gray-600 bg-gray-900'}`}>
                                                <div className="flex justify-between items-center mb-2">
                                                    <label className="font-semibold text-gray-200 text-sm">{slot.label}</label>
                                                    {isLoading && <div className="spinner"></div>}
                                                    {isLoaded && !isLoading && <span className="text-green-400 text-xs font-bold">{isCached ? 'CACHED' : 'READY'}</span>}
                                                </div>
                                                <input type="file" accept="video/mp4,video/*" disabled={isLoading || isLoaded} onChange={(e) => handleFileProcess(slot.id, e.target.files[0])} className="text-xs text-gray-400 w-full file:mr-2 file:py-1 file:px-2 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 cursor-pointer disabled:opacity-50"/>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Main Content Area - Split Video / Controls */}
                    <div className="flex-1 flex flex-col lg:flex-row min-h-0">
                        
                        {/* 1. VIDEO STAGE */}
                        <div className={`flex-none lg:flex-1 relative bg-black flex items-center justify-center overflow-hidden transition-all duration-300 ${isFullScreen ? 'h-full w-full' : ''}`}>
                            <div className="w-full h-full flex items-center justify-center p-4">
                                <div className={`video-wrapper ${getRatioClass()}`}>
                                    {videoSources['idle'] && (
                                        <video ref={idleVideoRef} src={videoSources['idle']} className={`layer ${!activeActionId ? 'active' : ''}`} loop muted playsInline />
                                    )}
                                    <canvas ref={actionCanvasRef} className={`layer ${activeActionId ? 'active' : ''}`}/>
                                    <div className="absolute top-4 left-4 bg-black/50 backdrop-blur px-3 py-1 rounded text-xs font-mono text-white z-20 pointer-events-none">
                                        STATE: {activeActionId ? activeActionId.toUpperCase() : 'IDLE'}
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* 2. CONTROLS DOCK - Independent Scroll */}
                        <div className={`flex-1 lg:w-[400px] lg:flex-none bg-gray-800/95 border-t lg:border-t-0 lg:border-l border-gray-700 flex flex-col min-h-0 ${isFullScreen ? 'absolute bottom-0 left-0 right-0 h-[40%] border-t shadow-2xl z-30' : ''}`}>
                            
                            <div className="p-4 border-b border-gray-700 flex justify-between items-center bg-gray-800 sticky top-0 z-10">
                                <h3 className="text-sm md:text-lg font-bold text-white">Controls</h3>
                                <div className="flex items-center space-x-2 bg-blue-900/20 px-2 py-1 rounded border border-blue-900/30">
                                    <span className="text-[10px] text-gray-400">Spring:</span>
                                    <input type="range" min="1" max="20" step="1" value={globalReturnSpeed} onChange={(e) => setGlobalReturnSpeed(parseFloat(e.target.value))} className="w-20 h-1.5 bg-gray-700 rounded-lg appearance-none cursor-pointer"/>
                                </div>
                            </div>

                            <div className="overflow-y-auto p-4 space-y-6 flex-1">
                                {VIDEO_SLOTS.filter(s => s.type === 'action').map(slot => {
                                    const currentVal = uiSliderValues[slot.id] !== undefined ? uiSliderValues[slot.id] : 50;
                                    const config = configs[slot.id] || { start: 0, neutral: 0, end: 0 };
                                    const frameCount = frameData[slot.id]?.length || 0;
                                    const currentFrame = getFrameIndex(slot.id, currentVal);

                                    return (
                                        <div key={slot.id} className="relative group bg-gray-900/50 p-3 rounded border border-gray-700/50">
                                            <div className="flex justify-between mb-2">
                                                <label className="text-xs font-semibold text-gray-300">{slot.label}</label>
                                                <span className="text-[10px] font-mono text-gray-500">{frameCount > 0 ? `${currentFrame}` : ''}</span>
                                            </div>
                                            <div className="relative h-10 mb-2">
                                                <input
                                                    type="range" min="0" max="100" step="0.1"
                                                    value={currentVal}
                                                    disabled={!frameData[slot.id]}
                                                    onMouseDown={() => handleSliderStart(slot.id)}
                                                    onTouchStart={() => handleSliderStart(slot.id)}
                                                    onInput={(e) => handleSliderMove(slot.id, e.target.value)}
                                                    onMouseUp={() => handleSliderEnd(slot.id)}
                                                    onTouchEnd={() => handleSliderEnd(slot.id)}
                                                    className="w-full h-full z-10 relative cursor-pointer disabled:cursor-not-allowed touch-none"
                                                />
                                                <div className="absolute top-0 bottom-0 left-1/2 w-0.5 bg-gray-600 -translate-x-1/2 pointer-events-none"></div>
                                            </div>
                                            
                                            {/* Compact Calibration */}
                                            <div className="flex space-x-1 mt-1">
                                                <input type="number" min="0" max={frameCount-1} value={config.start} onChange={(e) => handleConfigChange(slot.id, 'start', e.target.value)} className="w-full bg-gray-800 border border-gray-600 rounded px-1 text-[9px] text-gray-400 text-center" placeholder="Start"/>
                                                <input type="number" min="0" max={frameCount-1} value={config.neutral} onChange={(e) => handleConfigChange(slot.id, 'neutral', e.target.value)} className="w-full bg-gray-800 border border-blue-900/50 rounded px-1 text-[9px] text-blue-300 font-bold text-center" placeholder="Neutral"/>
                                                <input type="number" min="0" max={frameCount-1} value={config.end} onChange={(e) => handleConfigChange(slot.id, 'end', e.target.value)} className="w-full bg-gray-800 border border-gray-600 rounded px-1 text-[9px] text-gray-400 text-center" placeholder="End"/>
                                            </div>
                                        </div>
                                    );
                                })}
                                <div className="h-12"></div> {/* Spacer for scroll */}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>